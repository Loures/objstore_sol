% !TEX program = pdflatex
% !TEX options = -shell-escape -synctex=1 -interaction=nonstopmode -file-line-error "%DOC%"

\documentclass[a4paper,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[bookmarks]{hyperref}
\usepackage{minted}
\usepackage[toc,titletoc]{appendix}
\usepackage[ampersand]{easylist}

\usemintedstyle{emacs}
\hyphenation{lista double-linked}
\hyphenation{linkata}
\hyphenation{thread}

\begin{document}

\title{{\textbf{Progetto SOL (ObjStore)\\a.a. 2018-2019}}}
\author{Lorenzo Rasoini}
\date{}
\maketitle

\tableofcontents
\newpage

\part*{Scelte progettuali}
\addcontentsline{toc}{part}{Scelte progettuali}
Di seguito vengono presentate le varie scelte progettuali effettuate durante la realizzazione del progetto
\section{Strutture dati d'appoggio}
L'unica struttura dati utilizzata all'intero del progetto è \texttt{linkedlist} (lista double-linked concorrente) implementata all'interno
di \texttt{linkedlist.c}

Come per tutte le componenti del progetto la implementazione viene linkata all'eseguibile principale come file oggetto.

\subsection{\texttt{linkedlist}}
\begin{listing}[ht]
    \begin{minted}{C}
        typedef struct linkedlist_elem {
            void *ptr;
            struct linkedlist_elem *prev;
            pthread_mutex_t *prevmtx;
            pthread_mutex_t mtx;
            pthread_mutex_t *nextmtx;
            struct linkedlist_elem *next;
        } linkedlist_elem;
        \end{minted}
        \caption{Elemento della lista}
    \end{listing}
La lista double-linked è stata scelta per memorizzare i client connessi al server in un dato istante.
La scelta è stata dovuta alla facilità di implementazione e all'interesse che mi ha suscitato una sua implementazione in un contesto di programmazione concorrente.
Le procedure di ricerca \texttt{linkedlist\_search} e cancellazione \texttt{linkedlist\_delete} sono state dotate di un puntatore a una procedura esterna che permette di definire, rispettivamente, quale oggetto trovare e quale oggetto rimuovere.


\subsubsection*{Gestione della concorrenza}
Per gestire accessi e scritture all'interno della lista è stato implementato un meccanismo di \emph{"fine-grained locking"} ritenuto più efficente in relazione
all'utilizzo che viene fatto della lista all'interno del server.

Specificatamente, questo meccanismo è implementato tramite l'utilizzo di una lock: \texttt{mtx}, che blocca un singolo elemento della lista, e due puntatori a lock:
\texttt{prevmtx}, che punta alla lock dell'elemento precedente della lista (se esiste), e \texttt{nextmtx}, che punta alla lock dell'elemento successivo alla lista (se esiste).

Per evitare situazioni di deadlock le lock vengono sempre acquisite nello stesso ordine.

L'unica accortezza da avere nell'utilizzo di questa implementazione è l'allocare i dati puntati da \texttt{ptr} nell'heap del processo.

\section{Strutturazione del codice}
Il codice del server è strutturato in moduli che corrispondono a un gruppo di funzionalità separate richieste dal server:
\begin{itemize}
    \item \texttt{os\_server.c}
    
    Main del server e i meccanismi di gestione delle interruzioni.
    \item \texttt{dispatcher.c}
    
    Codice relativo al thread dispatcher, e meccanismi di gestione per il segnale \texttt{SIGUSR1}.
    \item \texttt{worker.c}
    
    Codice relativo ai worker threads assieme ai meccanismi di ricezione e preparazione dei messaggi inviati.

    \item \texttt{os\_client.c}
    
    Parsing dei messaggi e definizione di procedure per la gestione dei comandi individuati dal parser.
    
    \item \texttt{fs.c}
    
    Definizione di procedure inerenti la scrittura e lettura dei dati inviati e ricevuti dai client.
    
    \item \texttt{linkedlist.c}
    
    Implementazione di una lista double-linked concorrente.
\end{itemize}
\smallskip
Il codice dell'interfaccia è interamente contenuto all'interno di \texttt{objstore.c}.

L'header file \texttt{errormacros.h} contiene varie macro utilizzate per la gestione di eventuali errori lanciati da parte di chiamate di sistema.
\newpage
\part*{Funzionamento generale}
\addcontentsline{toc}{part}{Funzionamento generale}
\renewcommand*{\theHsection}{chY.\the\value{section}}
\setcounter{section}{0}
\section{Interazione intra-processo}
Il thread principale, dopo aver creato la socket e aver messo in piedi i meccanismi di gestione dei segnali, crea un thread dispatcher, il quale
si occupa di gestire le connessioni che arrivano alla socket. Ogni qualvolta si presenti una connessione il dispatcher controlla che il numero di client connessi
non superi 500, in caso positivo accetta la connessione e dopodiché crea un thread worker destinato a gestire tutti i messaggi inviati dal client fino
alla disconnessione di quest'ultimo.
\subsection{Comunicazione intra-processo}
La comunicazione intra-processo è basata su l'utilizzo di due variabili condivise: \texttt{OS\_RUNNING}, che segnala a tutti i thread del processo la terminazione
dello stesso, e \texttt{worker\_num}, dove al suo interno è memorizzato il numero di client connessi.
\subsection{Gestione della terminazione}
Il processo di gestione della terminazione ha inizio dopo l'arrivo di un segnale \texttt{SIGTERM} o \texttt{SIGINT}; in seguito alla ricezione di tale segnale
il thread adibito alla gestione dei segnali (il thread principale) setta \texttt{OS\_RUNNING} a 0.

A questo punto ogni thread worker rileverà il cambiamento della variabile, uscirà dal suo loop e inizierà la procedura di cleanup,
notificando al thread dispatcher l'avvenuta terminazione tramite la variabile di condizione \texttt{worker\_num\_cond}.

Appena \texttt{worker\_num} diventa 0 il thread dispatcher esegue la propria procedura di cleanup, termina e restituisce il controllo al thread principale che farà terminare il processo.
\section{Gestione dei segnali}
La gestione dei segnali \texttt{SIGINT} e \texttt{SIGTERM} avviene interamente all'interno del thread principale, il quale, dopo aver creato il dispatcher, si mette in attesa dei due segnali.

Per quanto riguarda la gestione di \texttt{SIGUSR1} è stata usata la tecnica del \emph{self-pipe trick}: il thread principale scrive su una pipe letta dal thread dispatcher; quest'ultimo
una volta rilevata la presenza di dati nella pipe la svuota ed esegue la procedura \texttt{stats}.

\section{Gestione della memoria}
Per quanto concerne la gestione della memoria si è cercato di usare il più possibile lo stack di ciascun thread e usare le allocazioni sullo heap solo per dati
di natura dinamica o di grandi dimensioni (in modo da evitare situazioni di stack overflow).

\begin{appendices}
    \section{SO su cui è stato testato il programma}
    \appendixname{Appendice A}
\begin{itemize}
    \item Arch Linux con kernel versione 5.1.15 e GCC versione 9.1.0
\end{itemize}
\end{appendices}

\end{document}